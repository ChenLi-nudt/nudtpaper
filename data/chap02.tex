\chapter{研究背景}
\label{chap:background}

\section{堆叠系统}

如今先进的三维堆叠芯片系统结构由于其在减少连线长度方面的天然优势，为减小未来芯片互连延迟和开销提供了非常有效的解决方案。
三维堆叠存储器的出现，能够为异构处理器提供更高的访存带宽，解决存储墙问题。
堆叠系统的这些优势使得我们有了许多为未来处理器体系结构提供创新设计的机会。

\subsection{三维堆叠集成}

%三维堆叠的基本概念和基本结构
三维堆叠封装技术属于最早的三维堆叠技术，是一种相对成熟的技术，已经在工业界得到了广泛应用。
三维堆叠封装技术通过\texttt{系统内集成封装（System-in-package, SiP）}或\texttt{封装内封装（Package-on-package, PoP）}技术将多个芯片垂直堆叠在一个基板上封装在一起，或者将多个封装号的芯片堆叠起来。
目前已经出现了许多成熟的采用三维封装技术的产品，包括在iPhone6中开始采用的Apple A8处理器，
将一个包含封装的双核CPU和4核GPU的处理器和一个1GB大小的LPDDR3 DRAM封装的存储器采用PoP技术封装在一起。
三维堆叠封装技术不要求在处理器结构和设计方法学上面做太大修改，因为这些技术的主要目标是为了节省空间，
芯片之间的通信仍然通过片外信号完成，因此无论是连接性和延迟都没有任何优势。

不同于三维堆叠封装技术，三维堆叠集成技术则是一种新兴技术。
三维堆叠集成技术将两或多层有源器件层，即CMOS晶体管层，在垂直方向上集成到一个芯片上。
堆叠芯片的层间提供了大量的互连资源，因此这种革命性的系统结构创新要求在设计方法学上的改变。
三维堆叠集成技术也可以分为两类：一类是\texttt{单晶堆叠方法（Monolithic Approach）}，该方法在单一晶元上完成三维集成电路所有的设计制作流程，
最后将其切成晶粒。该方法只需要一个衬底，无需对准、削薄、粘接等流程。
另一类则是普通的堆叠方法，可以进一步被划分为\texttt{wafer-to-wafer}、\texttt{die-to-wafer}、和\texttt{die-to-die}等方法。这些方法都是在分别制造每一层的芯片，
最后被组装粘接组成三维堆叠芯片。不同于复杂的\texttt{单晶堆叠方法}，不要求全新的设计制造技术，相对更加实际，也是三维集成电路技术的研究重点。


%三维堆叠的优势
相比于传统的集成电路技术，三维堆叠集成技术具有非常多的优势，我们从线长缩短、高访存带宽、异构集成和低成本四个角度介绍三维堆叠集成技术的优势：

\textbf{线长缩短}。芯片的全局连线延迟并没有按照摩尔定律的速度不断缩短，如今不断增加的全局连线延迟已经成为阻碍性能持续增长的重要原因之一。
三维堆叠集成技术能够有效克服全局连线延迟的瓶颈，为集成电路性能持续发展提供了解决方案。连线长度的缩减主要带来两方面巨大优势：延迟和功耗降低。
延迟的降低是由于平均线长和关键路径的缩短，而总线长的缩短也自然使得功耗大大降低。

\textbf{高存储带宽}。如今，如何为具有大量计算单元的GPU等异构处理器及时提供足够的数据已成为限制性能提升的重大挑战，因此提供高访存带宽尤为重要。
传统的片外存储单元由于受到I/O引脚的限制，难以提供足够的访存带宽。三维堆叠集成技术作为一种解决方案能为未来的微体系结构设计，特别是多核和众核处理器，
解决互连瓶颈、消除“存储墙”问题。通过将存储器堆叠在处理器芯片上，利用TSVs带来的通信优势提供远高于二维结构的通信带宽。

\textbf{异构集成}。三维堆叠集成技术为未来的体系结构设计提供了新的机会，即能够在新的维度进行设计空间探索。特别是异构集成能力，让我们从全新的角度研究系统结构的设计。
三维堆叠集成技术支持异构集成是由于其每一层都可以分开制造，不同的层也可以采用不同的工艺。
甚至可以在处理器层上堆叠光设备层、非易失性存储层或者是相变存储层，以实现高效异构系统结构。
这异构集成的实现可以为集成电路和芯片设计提供巨大的灵活性以满足性能、功耗和可靠性等要求。

\textbf{低成本}。随着集成电路规模不断增大，芯片的面积不断增大。但是由于缺陷密度相对恒定，较大的芯片晶粒大小意味着相对较低的良率。
而将多个较小的晶粒堆叠成一个相对较大规模的处理器增获得较高的良率，即使三维堆叠集成由于额外的制造复杂度可能会降低一定的良率。
另一方面，半导体集成电路的缩减也逐渐达到物理极限，继续缩减不但困难，成本也非常高。
因此三位堆叠集成技术潜在地提供了一种相比于传统集成电路更低成本的解决方案。


%三维堆叠的挑战
虽然三维堆叠集成技术带来了巨大的性能优势和在系统结构设计的机会，但在其广泛应用到未来的计算机系统前仍然需要解决几个重要的挑战：

\textbf{热问题}。功耗和热问题在传统的二维集成电路设计中已经成为一个重要的问题。
虽然三维堆叠集成技术相对于二维集成电路来说有许多的优势，然而将多个有源器件层堆叠起来大大增加了功耗密度，使得热问题进一步恶化，导致芯片温度升高。
芯片温度的升高又会反过来影响电路性能，如互连延迟会由于晶体管温度的升高而延长、静态功耗与温度是指数级依赖关系、温度升高还会导致热逃逸问题，此外，温度的升高会降低可靠性问题。

\textbf{设计工具和方法学}。如果没有辅助设计工具和方法学的支持，三维堆叠集成技术不可能商用化。
给定设计目标，高效的辅助设计工具和方法学可以帮助体系结构和电路设计者权衡三维堆叠电路在性能、功耗和开销。
相比于传统的二维集成电路，三维堆叠集成电路需要全新的布局规则，例如TSV布局、功耗计划等等。
高效的辅助设计工具还能够帮助分析热问题，在布局布线设计中避免热点区域的产生。

\textbf{测试问题}。在三维堆叠集成设计中，不同的测试策略和集成方法都可以严重影响系统的性能、功耗和开销问题。
三维堆叠集成电路技术目前没有广泛商用的另一个原因就是测试能力不足和缺乏面向三维堆叠集成技术的可测性设计技术。
如果没有在设计阶段考虑好测试问题，高效的三维集成测试时不可能的。
现在的三维堆叠集成测试上，一方面现在的探测技术不能够对所有的TSV进行探测；另一方面，测试过程很容易损坏被削薄的晶圆。



\subsection{基于硅中介层的2.5维堆叠}

三维堆叠集成技术可以将存储器直接堆叠在处理器晶圆之上。
不同于三维堆叠集成技术，2.5维堆叠策略的解决方案则是分别把存储器和处理器相邻地堆叠在硅中介层上，通过硅中介层的连线进行通信。
基于硅中介层的2.5维堆叠技术虽然是一代进化技术，但其能够在存储带宽和容量、热问题以及制造成本等方面表现出相对于三维堆叠集成技术更多的优势。

\textbf{存储容量和带宽}

对于三维堆叠集成，其主要优势是在两层间的最大潜在带宽受其面积限制。若采用直径50$\mu$s的TSV用作上下层的通信，
理论上一个200$cm^{2}$的芯片能够提供800万个TSVs。
相对地，对于2.5维堆叠集成，处理器和存储堆叠在硅中介层上的链接取决于处理器芯片的周长。
假设硅中介层上的连线直径也是50$\mu$s（全周长约56cm），则同样200$cm^{2}$的芯片仅能提供11000个连接点。
虽然三维堆叠和2.5维堆叠能提供的带宽有几个数量级的差异，但一个四通道的传统DDR3接口仅要求960个封装引脚。
硅中介层提供的成千上万的连接点已经可以避免这个瓶颈。
堆叠技术最重要的优势是将存储器和芯片封装在了一起，三维堆叠相对于2.5维堆叠更多的优势在这里实际并不明显。

而基于硅中介层的2.5维堆叠所能提供的存储容量则并不受限于处理器的面积，实际上能够堆叠在硅中介层上的堆叠存储的数目远远大于三维堆叠技术。
这是因为三维堆叠仅能从垂直方向上进行堆叠，受到了当前技术的限制。而硅中介层上的2.5维堆叠则能够支持多块堆叠存储水平分布，能够提供更大的存储容量。
当前的三维堆叠存储标准均为每块堆叠存储器提供了固定的带宽，因此总的存储带宽和容量取决于能够堆叠的存储器的数量。
对于当前的三维堆叠存储标准JEDEC HBM，提供1024位数据信号在1Gbps的平律师工作，每个堆叠存储能够提供128GB/s。 
而若4块HBM堆叠在硅中介层上，则总共能提供512GB/s的带宽。
假设一个HBM的大小为4GB，则基于硅中介层的2.5维堆叠能够提供16GB的存储容量，无论是带宽还是容量均优于三维堆叠技术。

\textbf{热问题}

基于硅中介层的2.5维堆叠相对于三维堆叠技术的另一个优势就是发热问题相对并不严重。
因为一般热问题比较严重的是处理器层，在2.5维堆叠技术上，处理器一般以单层的形式堆叠在硅中介层上，没有额外的层会堆叠在处理器上。
因此可以直接在处理器层上安装散热器。
当多块堆叠存储单元堆叠在硅中介层上时，温度虽然不会线性升高，但保持一个相对较低的温度依然对于降低刷新率和提高可靠性有重要意义。

\textbf{制造成本}

不同的堆叠技术要求不同的制造步骤，因此制造开销也会不一样。
基于硅中介层的2.5维堆叠技术相对于三维堆叠技术来说最明显的不同是2.5维堆叠技术需要增加额外的一个硅中介层的制造。
由于硅中介层需要更大的面积来堆叠更多的存储和处理器单元，且需要被削薄来支持TSV链接到C4 bumps。
因此硅中介层往往采用较老的一代半导体技术来实现。

三维堆叠结构的成本包括需要重新设计支持TSV的连接，这都是需要工程师的努力、EDA工具的支持、以及物理设计等。
同时TSV的面积和其周围的留空也需要为此增大芯片的面积。
而2.5维堆叠技术在处理器层不需要TSV，因此芯片无需削薄和面积的增大。

虽然2.5维堆叠和3维堆叠解决方案之间还有许多可以比较的优缺点，但根据上述的主要问题，我们认为2.5维堆叠技术对于异构系统来说非常令人期待。
堆叠异构系统采用2.5维堆叠技术可以获得更高的存储带宽和更大的存储容量，同时在热管理上也有更多的优势。
因此，本文研究的堆叠异构系统也主要基于2.5维堆叠技术，研究其在内存墙问题、多任务切换问题和网络负载均衡上的问题，并提供解决方案。

\section{GPU架构与编程模型}

%GPU历史
计算机辅助绘图最早出现在二十世纪六十年代，如Ivan Sutherland's Sketchpad~\cite{sutherland1964sketchpad}
从早期的计算机辅助绘图到电影动画的离线渲染和视频游戏的在线渲染，计算机图形处理不断发展。
最早的显卡是从1981年的IBM Monochrome显示适配器（MDA）开始，但当时只支持文字。
之后开始出现支持2D加速和3D加速，以及视频游戏的3D加速计算机辅助设计的图形显卡。
早期的3D图像处理器如NVIDIA的GeForce 3还只能支持相对单一的功能。
从2001年开始，NVIDIA以顶点着色器~\cite{lindholm2001user}和像素着色器的形式将可编程性引入了GPU，出现了NVIDIA Geforce 3图形处理器。
研究人员很快学习到如何在早期的这些GPU中通过将矩阵数据映射到纹理中以实现线性代数计算。
这些学术工作将通用计算任务映射到GPU上处理，这样程序员就不需要完全了解图形学以使用GPU。
这些努力促使GPU制造商在支持图形计算的同事还能够直接支持通用计算。
第一个实现通用计算能力的商业化GPU产品是NVIDIA GeForce 8系列。 
GeForce 8系列引入了多项创新，解决了早期GPU的不足，包括从Shader核写入数据到任意存储地址、便笺缓存等。
在NVIDIA Fermi架构中，GPU出现了缓存以暂存读或写的数据到片内。
随后的改进包括AMD的Fusion架构，它在同一芯片上集成了CPU和GPU，以及动态并行性，可以从GPU本身启动线程。
最近，NVIDIA的Volta推出了Tensor Cores等功能，专门用于机器学习加速。

\subsection{GPU架构}
%GPU 硬件基础
当前的GPU系统，GPU并不是能够独立工作的计算设备，而是与CPU一起合并到一块芯片或作为一个独立显卡连接到CPU组成一个系统工作。
CPU主要负责初始化GPU端的计算，然后将数据传输到GPU进行计算，并在GPU端计算完成后将数据结果传输回CPU。
在CPU和GPU之间进行这种分工的一个原因是计算的开始和结束通常需要访问输入/输出（I/O）设备。 
虽然正在不断努力开发直接在GPU上提供I/O服务的应用程序编程接口（API），但到目前为止这些CPU已经具有I/O的能力~\cite{silberstein2016gpunet}\cite{Silberstein:20139}。
这些API的功能在CPU和GPU之间提供了简单的通信接口，隐藏了复杂的管理过程。

如图所示的是包含CPU和GPU的典型系统的抽象图。左侧是典型的分立式GPU配置，包括连接CPU和GPU的总线（例如，PCIe或NVLink），广泛用于NVIDIA的GPU体系结构，如NVIDIA的Volta GPU。
右图是典型的集成CPU和GPU的逻辑图，如AMD的Bristol Ridge APU或移动端采用的GPU。
在这之中，包含分立式GPU的系统具有分别用于CPU（通常称为系统内存）和GPU（通常称为设备内存或显存）的独立DRAM存储空间。
用于这些存储器的DRAM技术通常是不同的（用于CPU的DDR与用于GPU的GDDR）。
CPU系统内存通常针对低延迟访问进行优化，而GPU的显存针对高吞吐量进行了优化。
相比之下，具有集成GPU的系统具有共同的DRAM存储器空间，因此必须使用相同的存储器技术。
由于集成的CPU和GPU经常在低功耗的移动设备上使用，因此共享DRAM存储器通常针对低功耗目标（例如，LPDDR）进行优化。

GPU计算应用程序开始运行应用程序将分配和初始化一些数据结构。
在NVIDIA和AMD的传统分立GPU上，GPU计算应用程序的CPU部分通常为CPU和GPU中的数据结构分配空间
应用程序的一部分必须协调数据从CPU内存到拷贝到GPU内存。 
最近新的分立式GPU（如NVIDIA Pascal/Volta系列）支持数据从CPU内存到GPU内存的自动传输。
这可以通过利用GPU虚拟内存实现。NVIDIA称之为“统一内存”（Unified Memory）。
对于CPU和GPU都集成到同一芯片上并共享相同的内存的情况，程序员不需要控制CPU内存到GPU内存的拷贝。
但是，由于CPU和GPU使用缓存，而其中一些缓存可能是私有的，因此可能存在Cache一致性问题，需要开发人员来解决。

在当前GPU系统中，CPU在其运行的驱动程序的帮助下完成对应用在GPU计算的初始化。
在启动GPU计算之前，在应用程序应明确在GPU上运行的代码。 
此代码通常称为内核函数（kernel）。 
同时GPU应用程序的CPU部分指定运行多少个线程、以及每个线程所需计算的数据的位置。
运行的内核函数，线程数和数据位置通过CPU上运行的驱动程序传送到GPU硬件。 
驱动程序将转换信息并将数据和信息存储在GPU可查找的位置。 
然后驱动程序向GPU发出信号，表明应用程序的GPU部分可以运行计算。

现代GPU由许多计算核组成。 
NVIDIA将这些计算核心称为流式多处理器（Stream Multiprocessor, SM），AMD将其称为计算单元(Compute Unit, CU)。 
每个GPU计算核执行与已经启动以在GPU上运行的内核函数相对应的单指令多线程（SIMT）程序。 
GPU上的每个计算核心通常可以运行大约一千个线程。 
在单个核上执行的线程可以通过便笺缓存进行通信，并使用快速栅栏操作进行同步。 
每个计算核心通常还包含指令和数据高速缓存。 
它们充当带宽过滤器，以减少发送到较低级别的内存系统的流量。 
在第一级高速缓存中找不到数据时，核心上运行的大量线程可以互相切换执行以隐藏访问内存的延迟。

为了维持高计算吞吐量，必须平衡高计算吞吐量和高存储器带宽。
这又需要存储器系统中的并行性。
在GPU中，一般通过采用多个存储器通道来提供这种并行性。
通常，每个存储器通道都将其与存储器分区中的上一级高速缓存的一部分相关联。 
GPU计算核心和内存分区通过片上互连网络（如交叉开关）连接。
当然，也有其他的组织结构类型。
例如，超级计算中广泛使用的GPU英特尔至强Phi协处理器则直接将最后一级缓存配置给每个计算核心。


%GPU 编程模型


\subsection{GPU编程模型}

GPU计算应用程序是从CPU上开始执行。
对于分立式GPU，应用程序的CPU部分通常会分配内存以用于GPU上的计算，然后启动输入数据到从CPU内存到GPU内存的传输，最后在GPU上启动内核函数开始计算。
对于集成GPU，可以直接开始启动内核函数进行计算，由于CPU和GPU共享物理内存，无需进行数据传输。
内核函数（Kernel）由数千个线程组成。
每个线程执行相同的程序，但是可以运行不同控制流，这取决于计算的结果和运行过程中的判断跳转。
下面我们使用CUDA编写的特定代码示例详细分析此流程。
%在下一节中，我们将查看程序集级别的执行模型。我们的讨论并没有详述GPU编程模型的性能方面。
然而，Seo等人观察到一个现象，在OpenCL上针对一个体系结构（例如，GPU）仔细优化过的代码可能在另一个体系结构（例如，CPU）上执行效果非常不好~\cite{seo2011performance}。

图~\ref{fig:ipe}提供了用于CPU实现一个大家熟知的操作，即单精度标量值A乘以矢量值X加矢量值Y的的C代码，称为SAXPY。 
SAXPY是众所周知的基本线性代数软件库（BLAS）的一部分，可用于实现更高级别的矩阵运算，如高斯消元法。 
鉴于其简单性和实用性，它经常被用作教授计算机体系结构的示例。

\begin{figure}[htbp] 
  \centering
  \begin{lstlisting}[language={[ANSI]C}]
void saxpy_serial(int n, float a, float *x, float *y)
{
    for (int i = 0; i < n; ++i)
        y[i] = a*x[i] + y[i];
}

main() 
{
    float *x, *y;
    int n;
    // `忽略初始化`x`和`y`的操作`
    saxpy_serial(n, 2.0, x, y); //`调用串行计算`SAXPY`函数`
    // `忽略释放`x`和`y`的操作`
}
\end{lstlisting} 
\caption{C代码版本的SAXPY计算}
\label{fig:csaxpy}
\end{figure}


\begin{figure}[htbp]
\centering
\begin{lstlisting}[language={[ANSI]C}]
__global__ void saxpy(int n, float a, float *x, float *y)
{
    int i = blockIdx.x*blockDim.x + threadIdx.x;
    if(i<n)
        y[i] = a*x[i] + y[i];
}
int main() {
    float *h_x, *h_y;
    int n;
    //`忽略给`h_x`和`h_y`在`CPU`分配空间和初始化的代码部分`
    float *d_x, *d_y;
    int nblocks = (n + 255) / 256;
    cudaMalloc( &d_x, n * sizeof(float) );
    cudaMalloc( &d_y, n * sizeof(float) );
    cudaMemcpy( d_x, h_x, n * sizeof(float), cudaMemcpyHostToDevice );
    cudaMemcpy( d_y, h_y, n * sizeof(float), cudaMemcpyHostToDevice );
    saxpy<<<nblocks, 256>>>(n, 2.0, d_x, d_y); //`调用并行计算`SAXPY`的`GPU`内核函数`
    cudaMemcpy( h_x, d_x, n * sizeof(float), cudaMemcpyDeviceToHost );
    //`忽略为`h_x`、`h_y`、`d_x`和`d_y`释放空间的代码部分`
}
\end{lstlisting} 
\caption{CUDA代码版本的SAXPY计算}
\label{fig:cudasaxpy}
\end{figure}



图~\ref{fig:csaxpy}中的示例演示了SAXPY的C代码形式。
代码函数\texttt{main()}开始执行执行。 为了使例子专注于计算过程，我们暂时省略分配和初始化数组x和y的细节。 
接下来，调用函数\texttt{saxpy\_serial}。 
此函数将参数n中向量x和y中的元素数量，参数a中的标量值以及用于表示向量x和y的数组的指针作为输入参数。 
该函数迭代数组x和y的每个元素。 
在每次迭代中，第4行的代码使用循环变量i读取值x[i]和y[i]，将x[i]乘以a然后加y[i]，然后用结果更新到x[i]。
 
图~\ref{fig:cudasaxpy}则提供了相应的SAXPY的CUDA版本，可以在CPU和GPU之间分别执行相应部分的代码。
与传统的C或C++应用程序类似，图~\ref{fig:cudasaxpy}中的代码通过在CPU上运行\texttt{main()}函数开始执行。 
我们将重点放在GPU部分执行的代码。
在GPU上执行的线程是由函数指定的计算内核函数（kernel）的一部分。 
在SAXPY的CUDA版本中，如图~\ref{fig:cudasaxpy}所示，第1行的CUDA关键字\texttt{\_\_global\_\_}表示内核函数saxpy将在GPU上运行。 
在该示例中，我们已经并行化了图~\ref{fig:csaxpy}中CPU示例的\texttt{for}循环。 
具体来说，图~\ref{fig:csaxpy}中原始CPU专用C代码中第4行\texttt{for}循环的每次迭代都被转换为运行图~\ref{fig:csaxpy}中第3-5行代码的每个独立线程。

在我们的示例中，CPU在第17行调用CUDA的内核函数配置语法的启动GPU上的计算。
内核函数配置语法看起来很像C中的函数调用，其中一些附加信息指定了三角括号\texttt{（<<< >>>）}之间包含的线程数。
组成内核函数的线程被组织成一个层次结构，该层次结构由包含网格（grid）、线程块和warp三级组成。
warp一般由32个或64个线程组成，多个warp组成一个线程块，多个线程块组成一个网格。
在CUDA编程模型中，各个线程执行其操作数是标量值（例如，32位浮点）的指令。
为了提高效率，典型的GPU硬件同步执行若干个线程组。这些组被NVIDIA称为warp，AMD称为wavefronts。 NVIDIA warps由32个线程组成，而AMD wavefronts由64个线程组成。 
Warp被分组为一个更大的单元，称为协作线程阵列（CTA）或NVIDIA的线程块。
第17行表示内核函数应该启动由\texttt{nblocks}个线程块组成的单个网格，其中每个线程块包含256个线程。
CPU代码传递给内核配置表达式的参数将被分发到GPU上正在运行的线程的每个实例。

今天的许多移动设备片上系统将CPU和GPU集成到单个芯片中，就像今天的笔记本电脑和台式电脑上的处理器一样。 
然而，传统GPU具有自己的DRAM存储器，并且今天对于用于机器学习的数据中心内的GPU而言仍然是这样。 
我们注意到NVIDIA推出了统一内存，它可以从CPU内存透明地更新GPU内存，从GPU内存中透明地更新CPU内存。 
在启用统一内存的系统中，驱动和硬件负责数据的传输拷贝，而无需程序员手动操作。
这种方法极大的减轻了程序员的负担，我们的内存超额配置管理框架也是基于统一内存的概念。
但在图~\ref{fig:cudasaxpy}这个例子中，我们为了简单理解，采用了传统的程序员控制内存拷贝的形式。

遵循许多NVIDIA CUDA示例中的风格，我们在为CPU内存中分配空间时命名指针变量使用前缀\texttt{h\_}，在GPU内存中分配内存的指针使用\texttt{d\_}。 
在第13行，CPU调用CUDA库函数\texttt{cudaMalloc}。 
此函数调用GPU驱动程序并要求它在GPU上分配内存以供程序使用。 
对\texttt{cudaMalloc}的调用将\texttt{d\_x}设置为指向GPU内存区域，该区域包含足够的空间来容纳n个32位浮点值。 
在第15行，CPU调用CUDA库函数\texttt{cudaMemcpy}。 
此函数调用GPU驱动程序并要求它从\texttt{h\_x}指向CPU内存的位置复制数组的内容到由\texttt{d\_x}指向的GPU内存中的位置。

对于GPU上线程的执行，并行编程中采用的通用策略是为每个线程分配一部分数据。
为了实现这种策略，GPU上的每个线程都可以在线程块网格中查找自己的id。
在CUDA中执行此操作的机制使用网格，线程块和线程标识符来明确id。
在CUDA中，网格和线程块具有x，y和z维度。
在执行时，每个线程在网格和线程块内具有固定的，唯一的非负整数x，y和z坐标组合，这是每个线程块在网格中的x，y和z坐标。
类似地，每个线程在线程块内具有x，y和z坐标。
这些坐标的范围由内核配置语句设置（第17行）。
在我们的示例中，未指定y和z维度，因此所有线程的y和z线程块和线程坐标的值都为零。
在第3行，\texttt{threadIdx.x}的值标识其线程块和\texttt{blockIdx.x}中线程的x坐标。

在我们的示例中，未指定y和z维度，因此所有线程的y和z线程块和线程坐标的值都为零。
在第3行，\texttt{threadIdx.x}的值标识其线程块内线程的x坐标；
\texttt{blockIdx.x}指示其网格中线程块的x坐标；
值\texttt{blockDim.x}表示x维度中的最大线程数。
在我们的示例中，\texttt{blockDim.x}在第17行被置为256。
表达式\texttt{blockIdx.x * blockDim.x + threadIdx.x}用于计算在访问数组x和y时使用的偏移量i 。
正如我们将看到的，使用索引i，我们为每个线程分配了x和y的唯一元素。

在很大程度上，编译器和硬件的组合使程序员无需了解warp中线程执行的锁步特性。 
编译器和硬件使得warp中的每个线程能够独立执行。 
在图~\ref{fig:cudasaxpy}中的第4行，我们将索引i的值与n（数组x和y的大小，即总线程数）进行比较。 
i小于n的线程执行第5行。
图~\ref{fig:cudasaxpy}中的第5行执行图~\ref{fig:csaxpy}中原始循环的一次迭代。 
在网格中的所有线程完成后，内核函数返回，在第17行之后继续由CPU执行。
在第18行，CPU调用GPU驱动程序将\texttt{d\_y}指向的数组从GPU内存复制回CPU内存。

下面我们介绍一些SAXPY示例未说明的其他细节。
一个线程块中的线程可以通过每个流多核处理器的便笺存储器相互高效通信。这个便笺存储器被NVIDIA称为共享内存（share memory）。
每个流多核处理器包含一个共享内存。
共享内存中的空间在该SM上运行的所有线程块之间划分。每个线程块拥有一块独立的空间。
AMD的新一代GPU架构GCN包括一个类似的内存，AMD称之为本地数据存储（Local Data Store, LDS）。
这些内存很小，每个有16-64KB，并作为一个特殊的内存空间给程序员控制。
程序员在源代码中使用特殊关键字将内存分配到便笺存储器中（例如，CUDA中的\texttt{“\_\_shared\_\_”}）。
便笺存储器可以被理解为软件控制的高速缓存。
虽然GPU还包含传统的缓存，但通过这些缓存访问数据可能导致频繁的缓存未命中。
当程序员可以识别经常重复使用的数据时，应用程序可以预测并使用便笺存储器
与NVIDIA的GPU不同，AMD的GCN GPU还包括GPU上所有内核共享的全局数据存储器（Global Data Store, GDS）。
便笺存储器用于图形应用程序，以在不同的计算核心之间传递结果。
例如，LDS用于在GCN架构的GPU中传递顶点和像素着色器之间的参数值。
线程块中的线程可以使用硬件支持的栅栏指令有效地同步。 
不同线程块中的线程可以通过所有线程都可访问的全局内存进行通信。 
访问全局内存在时间和功耗方面都比访问共享内存的开销要大很多。



\section{异构系统的策略优化}

\subsection{软件策略优化}

\subsection{硬件策略优化}

















% 本章将进入论文排版的正文, 按元素分主要包括：
% {\kai 字体段落，图片表格，公式定理，参考文献}这几部分。
% 这个样例文件将包括模板中使用到的所有格式、模板中自定义命令到或者特有的东西，
% 都将被一一介绍，希望大家在排版自己的学位论文前能细致的看一遍，记住样例的格式和
% 方法，方便上手。

% \section{字体段落}
% \label{sec:font}

% 陈赓（1903年2月27日－1961年3月16日），原名陈庶康，中国湖南湘乡人，军事家。出生将门，其祖父为湘军将领陈翼怀。

% Adobe中文字体有四种：

% {\kai 楷体\verb|\kai|：陈赓，中国湖南湘乡人，军事家。出生将门，其祖父为湘军将领陈翼怀。%
% 1952年筹办并任人民解放军军事工程学院第一任院长兼政委，培养国防科技人才。1955年被授予大将军衔。}

% {\fs 仿宋\verb|\fs|：陈赓，中国湖南湘乡人，军事家。出生将门，其祖父为湘军将领陈翼怀。%
% 1952年筹办并任人民解放军军事工程学院第一任院长兼政委，培养国防科技人才。1955年被授予大将军衔。}

% {\hei 黑体\verb|\hei|：陈赓，中国湖南湘乡人，军事家。出生将门，其祖父为湘军将领陈翼怀。%
% 1952年筹办并任人民解放军军事工程学院第一任院长兼政委，培养国防科技人才。1955年被授予大将军衔。}

% 宋体就是正文字体了。下面测试字体大小，\LaTeX{}默认的列表环境会在
% 条目之间插入过多的行距，在下面这种情况可能正好，若用户需要
% {\kai 正文行距}的列表环境，可以使用compactitem环境，记住这点很重要，不要再
% 用那种自己修改\verb|itemsep|的傻傻的办法了。
% \begin{itemize}
% \item[初号] {\song\chuhao 陈赓大将}
% \item[小初] {\song\xiaochu 陈赓大将}
% \item[一号] {\song\yihao 陈赓大将}
% \item[小一] {\song\xiaoyi 陈赓大将}
% \item[二号] {\song\erhao 陈赓大将}
% \item[小二] {\song\xiaoer 陈赓大将}
% \item[三号] {\song\sanhao 陈赓大将}
% \item[小三] {\song\xiaosan 陈赓大将}
% \item[四号] {\song\sihao 陈赓大将}
% \item[小四] {\song\xiaosi 陈赓大将}
% \item[五号] {\song\wuhao 陈赓大将}
% \item[小五] {\song\xiaowu 陈赓大将}
% \end{itemize}

% \section{表格明细}
% \label{sec:figure}
% 表格是论文的重要组成部分，我们从简单的表格讲起，到复杂的表格为止。

% 模板中关于表格的宏包有三个： \textsf{booktabs}、\textsf{array} 和
% \textsf{longtabular}。三线表建议使用\textsf{booktabs}中提供的，
% 包含toprule、midrule 和 bottomrule三条命令，简单干脆！
% 它们与\textsf{longtable} 能很好的配合使用。下面来看一个表格实例：
% \begin{table}[htb]
%   \centering
%   \begin{minipage}[t]{0.8\linewidth} % 如果想在表格中使用脚注，minipage是个不错的办法
%   \caption[模板文件]{模板文件。如果表格的标题很长，那么在表格索引中就会很不美
%     观，所以要像 chapter 那样在前面用中括号写一个简短的标题。这个标题会出现在索
%     引中。}
%   \label{tab:template-files}
%     \begin{tabular*}{\linewidth}{lp{10cm}}
%       \toprule[1.5pt]
%       {\hei 文件名} & {\hei 描述} \\
%       \midrule[1pt]
%       nudtpaper.ins & \LaTeX{} 安装文件，docstrip\footnote{表格中的脚注} \\
%       nudtpaper.dtx & 所有的一切都在这里面\footnote{再来一个}。\\
%       nudtpaper.cls & 模板类文件。\\
%       nudtpaper.cfg & 模板配置文。cls 和 cfg 由前两个文件生成。\\
%       bstutf8.bst   & 参考文献 Bibtex 样式文件。\\
%       mynudt.sty    & 常用的包和命令写在这里，减轻主文件的负担。\\
%       \bottomrule[1.5pt]
%     \end{tabular*}
%   \end{minipage}
% \end{table}

% 表 \ref{tab:template-files} 列举了本模板主要文件及其功能，基本上来说论文
% 中最可能用到的就是这种表格形式了。
% 请大家注意三线表中各条线对应的命令。这个例子还展示了如何在表格中正确使用脚注。
% 如果你不需要在表格中插入脚注，可以将minipage环境去掉。
% 由于\LaTeX{}本身不支持在表格中使用\verb|\footnote|，所以我们不得不将表格放在
% 小页中，而且最好将表格的宽度设置为小页的宽度，这样脚注看起来才更美观。

% 另外六院的同学在使用模板时需要使用一种固定宽度（往往是页宽，下面的例子由
% rongdonghu提供）的表格，内容需要居中且可以自动调整。
% 解决办法是自定义了一种\verb|tabularx|中的\textbf{Z}环境，在论文模板中，
% 该命令已添加到\verb|mynudt.sty|中。下面是这种情况的实例：

% \begin{table}[htbp]
% \centering
% \begin{minipage}[t]{0.9\linewidth}
% \caption{Reed Solomon码的典型应用}
% \label{tab:RSuse}
% \begin{tabularx}{\linewidth}{cZ}
% \toprule[1.5pt]
% {\hei 应用领域} & {\hei 编码方案}\\
% \midrule[1pt]
% 磁盘驱动器 & RS(32,28,5)码 \footnote{码长为32、维数为28、最小距离为5} \\
% CD & 交叉交织RS码(CIRC) \\
% DVD & RS(208,192,17)码、RS(182,172,11)码 \\
% 光纤通信 & RS(255,229,17)码 \\
% \bottomrule[1.5pt]
% \end{tabularx}
% \end{minipage}
% \end{table}

% 我们经常会在表格下方标注数据来源，或者对表格里面的条目进行解释。前面的脚注是一种
% 不错的方法，如果你不喜欢minipage方法的脚注。
% 那么完全可以在表格后面自己写注释，比如表~\ref{tab:tabexamp1}。
% \begin{table}[htbp]
%   \centering
%   \caption{复杂表格示例 1}
%   \label{tab:tabexamp1}
%   \begin{minipage}[t]{0.8\textwidth} 
%     \begin{tabularx}{\linewidth}{|l|X|X|X|X|}
%       \hline
%       \multirow{2}*{\backslashbox{x}{y}}  & \multicolumn{2}{c|}{First Half} & \multicolumn{2}{c|}{Second Half}\\
%       \cline{2-5}
%       & 1st Qtr &2nd Qtr&3rd Qtr&4th Qtr \\ 
%       \hline
%       \multirow{2}*{East$^{*}$} &   20.4&   27.4&   90&     20.4 \\
%        &   30.6 &   38.6 &   34.6 &  31.6 \\ 
%       West$^{**}$ &   30.6 &   38.6 &   34.6 &  31.6 \\ 
%       \hline
%     \end{tabularx}\\[2pt]
%     \footnotesize
%     *：东部\\
%     **：西部
%   \end{minipage}
% \end{table}

% 此外，表~\ref{tab:tabexamp1} 同时还演示了另外三个功能：1）通过 \textsf{tabularx} 的
%  \texttt{|X|} 扩展实现表格内容自动调整；2）通过命令 \verb|\backslashbox| 在表头部分
% 插入反斜线（WORD中很简单，但\LaTeX{}做表格需要一定的（极大的）想象力）；3）就是
% 使用\verb|multirow|和\verb|multicolumn|命令。

% 不可否认 \LaTeX{} 的表格功能没有想象中的那么强大，不过只要你足够认真，足够细致，那么
% 同样可以排出来非常复杂非常漂亮的表格。可是科技论文中那么复杂表格有什么用呢？
% 上面那个表格就够用啦。

% 浮动体的并排放置一般有两种情况：1）二者没有关系，为两个独立的浮动体；2）二者隶属
% 于同一个浮动体。对表格来说并排表格既可以像表~\ref{tab:parallel1}、表~\ref{tab:parallel2} 
% 使用小页环境，也可以如表~\ref{tab:subtable}使用子表格来做。
% 图与表同出一源，后面我们将讲解子图(subfloat)的例子。
% \begin{table}[htb]
% \centering
% \noindent\begin{minipage}{0.45\textwidth}
% \centering
% \caption{第一个并排子表格}
% \label{tab:parallel1}
% \begin{tabular}{p{2cm}p{2cm}}
% \toprule[1.5pt]
% 111 & 222 \\\midrule[1pt]
% 222 & 333 \\\bottomrule[1.5pt]
% \end{tabular}
% \end{minipage}
% \begin{minipage}{0.45\textwidth}
% \centering
% \caption{第二个并排子表格}
% \label{tab:parallel2}
% \begin{tabular}{p{2cm}p{2cm}}
% \toprule[1.5pt]
% 111 & 222 \\\midrule[1pt]
% 222 & 333 \\\bottomrule[1.5pt]
% \end{tabular}
% \end{minipage}
% \end{table}
% \begin{table}[htbp]
% \centering
% \caption{并排子表格}
% \label{tab:subtable}
% \subfloat[第一个子表格]{
% \begin{tabular}{p{2cm}p{2cm}}
% \toprule[1.5pt]
% 111 & 222 \\\midrule[1pt]
% 222 & 333 \\\bottomrule[1.5pt]
% \end{tabular}}\hskip2cm
% \subfloat[第二个子表格]{
% \begin{tabular}{p{2cm}p{2cm}}
% \toprule[1.5pt]
% 111 & 222 \\\midrule[1pt]
% 222 & 333 \\\bottomrule[1.5pt]
% \end{tabular}}
% \end{table}

% 如果您要排版的表格长度超过一页，那么推荐使用\textsf{longtable}命令。
% 这里随便敲入一些无关的文字，使得正文看上去不是那么的少。
% 表~\ref{tab:performance} 就是 \textsf{longtable} 的简单示例。
% \begin{longtable}[c]{c*{6}{r}}
% \caption{实验数据}\label{tab:performance}\\
% \toprule[1.5pt]
%  测试程序 & \multicolumn{1}{c}{正常运行} & \multicolumn{1}{c}{同步}
% & \multicolumn{1}{c}{检查点}   & \multicolumn{1}{c}{卷回恢复}
% & \multicolumn{1}{c}{进程迁移} & \multicolumn{1}{c}{检查点} 	\\
% & \multicolumn{1}{c}{时间 (s)} & \multicolumn{1}{c}{时间 (s)}
% & \multicolumn{1}{c}{时间 (s)} & \multicolumn{1}{c}{时间 (s)}
% & \multicolumn{1}{c}{时间 (s)} &  文件（KB）			\\
% \midrule[1pt]%
% \endfirsthead%

% \multicolumn{7}{c}{续表~\thetable\hskip1em 实验数据}\\

% \toprule[1.5pt]
%  测试程序 & \multicolumn{1}{c}{正常运行} & \multicolumn{1}{c}{同步} 
% & \multicolumn{1}{c}{检查点}   & \multicolumn{1}{c}{卷回恢复}
% & \multicolumn{1}{c}{进程迁移} & \multicolumn{1}{c}{检查点} 	\\
% & \multicolumn{1}{c}{时间 (s)} & \multicolumn{1}{c}{时间 (s)}
% & \multicolumn{1}{c}{时间 (s)} & \multicolumn{1}{c}{时间 (s)}
% & \multicolumn{1}{c}{时间 (s)} &  文件（KB）			\\
% \midrule[1pt]%
% \endhead%
% \hline%

% \multicolumn{7}{r}{续下页}%

% \endfoot%
% \endlastfoot%
% CG.A.2 & 23.05   & 0.002 & 0.116 & 0.035 & 0.589 & 32491  \\
% CG.A.4 & 15.06   & 0.003 & 0.067 & 0.021 & 0.351 & 18211  \\
% CG.A.8 & 13.38   & 0.004 & 0.072 & 0.023 & 0.210 & 9890   \\
% CG.B.2 & 867.45  & 0.002 & 0.864 & 0.232 & 3.256 & 228562 \\
% CG.B.4 & 501.61  & 0.003 & 0.438 & 0.136 & 2.075 & 123862 \\
% CG.B.8 & 384.65  & 0.004 & 0.457 & 0.108 & 1.235 & 63777  \\
% MG.A.2 & 112.27  & 0.002 & 0.846 & 0.237 & 3.930 & 236473 \\
% MG.A.4 & 59.84   & 0.003 & 0.442 & 0.128 & 2.070 & 123875 \\
% MG.A.8 & 31.38   & 0.003 & 0.476 & 0.114 & 1.041 & 60627  \\
% MG.B.2 & 526.28  & 0.002 & 0.821 & 0.238 & 4.176 & 236635 \\
% MG.B.4 & 280.11  & 0.003 & 0.432 & 0.130 & 1.706 & 123793 \\
% MG.B.8 & 148.29  & 0.003 & 0.442 & 0.116 & 0.893 & 60600  \\
% LU.A.2 & 2116.54 & 0.002 & 0.110 & 0.030 & 0.532 & 28754  \\
% LU.A.4 & 1102.50 & 0.002 & 0.069 & 0.017 & 0.255 & 14915  \\
% LU.A.8 & 574.47  & 0.003 & 0.067 & 0.016 & 0.192 & 8655   \\
% LU.B.2 & 9712.87 & 0.002 & 0.357 & 0.104 & 1.734 & 101975 \\
% LU.B.4 & 4757.80 & 0.003 & 0.190 & 0.056 & 0.808 & 53522  \\
% LU.B.8 & 2444.05 & 0.004 & 0.222 & 0.057 & 0.548 & 30134  \\
% EP.A.2 & 123.81  & 0.002 & 0.010 & 0.003 & 0.074 & 1834   \\
% EP.A.4 & 61.92   & 0.003 & 0.011 & 0.004 & 0.073 & 1743   \\
% EP.A.8 & 31.06   & 0.004 & 0.017 & 0.005 & 0.073 & 1661   \\
% EP.B.2 & 495.49  & 0.001 & 0.009 & 0.003 & 0.196 & 2011   \\
% EP.B.4 & 247.69  & 0.002 & 0.012 & 0.004 & 0.122 & 1663   \\
% EP.B.8 & 126.74  & 0.003 & 0.017 & 0.005 & 0.083 & 1656   \\
% \bottomrule[1.5pt]
% \end{longtable}

% 另外，有的同学不想让某个表格或者图片出现在索引里面，那么请使用命令 \verb|\caption*{}|，
% 这个命令不会给表格编号，也就是出来的只有标题文字而没有“表~XX”，“图~XX”，否则
% 索引里面序号{\kai 不连续}就显得不伦不类，这也是 \LaTeX{} 里星号命令默认的规则。

% \section{绘图插图}

% 本模板不再预先装载任何绘图包（如 \textsf{pstricks，pgf} 等），完全由你自己来决定。
% 个人觉得 \textsf{pgf} 不错，不依赖于 Postscript。此外还有很多针对 \LaTeX{} 的
%  GUI 作图工具，如 XFig(jFig), WinFig, Tpx, Ipe, Dia, Inkscape, LaTeXPiX,
% jPicEdt 等等。本人强烈推荐\textsf{Ipe}。

% 一般图形都是处在浮动环境中。之所以称为浮动是指最终排版效果图形的位置不一定与源文
% 件中的位置对应，这也是刚使用 \LaTeX{} 同学可能遇到的问题。
% 如果要强制固定浮动图形的位置，请使用 \textsf{float} 宏包，
% 它提供了 \texttt{[H]}（意思是图片就给我放在这里\textcolor{red}{H}ere）参数，
% 但是除非特别需要，不建议使用\texttt{[H]}，而是推荐使用\texttt{[htbp]}，
% 给\LaTeX{}更多选择。比如图~\ref{fig:ipe}。
% \begin{figure}[htbp] % use float package if you want it here
%   \centering
%   \includegraphics[width=3in]{hello}
%   \caption{利用IPE制图}
%   \label{fig:ipe}
% \end{figure}

% 若子图共用一个计数器，
% 那么请看图~\ref{fig:big1}，它包含两个小图，分别是图~\ref{fig:subfig1} 
% 和图~\ref{fig:subfig2}。这里推荐使用\verb|\subfloat|，{\bf 不要再用}
% \verb|\subfigure|和\verb|\subtable|。
% \begin{figure}[htb]
%   \centering%
%   \subfloat[第一个小图形]{%
%     \label{fig:subfig1}
%     \includegraphics[height=2cm]{xh}}\hspace{4em}%
%   \subfloat[第二个小图形。如果标题很长的话，它会自动换行，这个 caption 就是这样的例子]{%
%     \label{fig:subfig2}
%     \includegraphics[height=2cm]{xhh}}
%   \caption{包含子图形的大图形}
%   \label{fig:big1}
% \end{figure}

% 而下面这个例子显示并排$3\times2$的图片，见图\ref{fig:subfig:3x2}:
% \begin{figure}[htb]
% \centering
% \subfloat[]{\includegraphics[width=.27\textwidth]{typography}} \qquad
% \subfloat[]{\includegraphics[width=.27\textwidth]{typography}} \qquad
% \subfloat[]{\includegraphics[width=.27\textwidth]{typography}} \qquad
% \subfloat[]{\includegraphics[width=.27\textwidth]{typography}} \qquad
% \subfloat[]{\includegraphics[width=.27\textwidth]{typography}} \qquad
% \subfloat[]{\includegraphics[width=.27\textwidth]{typography}}
% \caption{并排图片}
% \label{fig:subfig:3x2}
% \end{figure}

% 要注意，图\ref{fig:subfig:3x2}例中
% \texttt{qquad}相当于\verb|\hspace{2em}|，也就是2个字符的宽度，约0.08倍页宽，
% 图片宽度设定为0.27倍页宽是合适的；在该环境中，尽量不要手动换行，所以，不妨自己计算一下！

% 如果要把编号的两个图形并排，那么小页(minipage)就非常有用了，可以分别参考
% 图\ref{fig:parallel1}和图\ref{fig:parallel2}。其实这个例子和表格一节中并排
% 放置的表格一摸一样。
% \begin{figure}[htb]
% \begin{minipage}{0.48\textwidth}
%   \centering
%   \includegraphics[height=1.2cm]{xhh}
%   \caption{并排第一个图}
%   \label{fig:parallel1}
% \end{minipage}\hfill
% \begin{minipage}{0.48\textwidth}
%   \centering
%   \includegraphics[height=1.2cm]{xhh}
%   \caption{并排第二个图}
%   \label{fig:parallel2}
% \end{minipage}
% \end{figure}

% 图形就说这么多，因为大家在写论文是遇到的最大问题不是怎么把图插进去，
% 而是怎样做出专业的、诡异的、震撼的图片来，记得在这时参考前面推荐的那
% 些工具吧，当然必不可少的是Matlab了，至于如何加入中文标注、支持中文等等
% 可以上网去查，但这里{\kai 推荐一点}，用好export命令，使得插入图片时尽可能的不要
% 缩放，保证图文的一致性。

% \section{公式定理}
% \label{sec:equation}
% 贝叶斯公式如式~(\ref{equ:chap1:bayes})，其中$p(y|\mathbf{x})$为后验；
% $p(\mathbf{x})$为先验；分母$p(\mathbf{x})$ 为归一化因子，这是
% 实际应用中十分恐怖的一个积分式。
% \begin{equation}
% \label{equ:chap1:bayes}
% p(y|\mathbf{x}) = \frac{p(\mathbf{x},y)}{p(\mathbf{x})}=
% \frac{p(\mathbf{x}|y)p(y)}{p(\mathbf{x})} 
% \end{equation}

% 论文里面公式越多，\TeX{} 就越 happy。再看一个 \textsf{amsmath} 的例子：
% \newcommand{\envert}[1]{\left\lvert#1\right\rvert} 
% \begin{equation}\label{detK2}
% \det\mathbf{K}(t=1,t_1,\dots,t_n)=\sum_{I\in\mathbf{n}}(-1)^{\envert{I}}
% \prod_{i\in I}t_i\prod_{j\in I}(D_j+\lambda_jt_j)\det\mathbf{A}
% ^{(\lambda)}(\overline{I}|\overline{I})=0.
% \end{equation} 

% 大家在写公式的时候一定要好好看\textsf{amsmath}的文档，并参考模板中的用法：
% \begin{multline*}%\tag{[b]} % 这个出现在索引中的
% \int_a^b\biggl\{\int_a^b[f(x)^2g(y)^2+f(y)^2g(x)^2]
%  -2f(x)g(x)f(y)g(y)\,dx\biggr\}\,dy \\
%  =\int_a^b\biggl\{g(y)^2\int_a^bf^2+f(y)^2
%   \int_a^b g^2-2f(y)g(y)\int_a^b fg\biggr\}\,dy
% \end{multline*}

% 再看\ref{equ:split}:
% \begin{equation}\label{equ:split}
% \begin{split}
% C(z) &= [z^n] \biggl[\frac{e^{3/4}}{\sqrt{1-z}} +
% e^{-3/4}(1-z)^{1/2} + \frac{e^{-3/4}}{4}(1-z)^{3/2}
% + O\Bigl( (1-z)^{5/2}\Bigr)\biggr] \\
% &= \frac{e^{-3/4}}{\sqrt{\pi n}} - \frac{5e^{-3/4}}{8\sqrt{\pi
% n^3}} + \frac{e^{-3/4}}{128 \sqrt{\pi n^5}} +
% O\biggl(\frac{1}{\sqrt{\pi
% n^7}}\biggr)
% \end{split}
% \end{equation}

% 当然了，数学中必不可少的是定理和证明：
% \begin{theorem}
%   \label{chapTSthm:rayleigh solution}
%   假定 $X$ 的二阶矩存在:
%   \begin{equation}
%          O_R(\mathbf{x},F)=\sqrt{\frac{\mathbf{u}_1^T\mathbf{A}\mathbf{u}_1} {\mathbf{u}_1^T\mathbf{B}\mathbf{u}_1}}=\sqrt{\lambda_1},
%   \end{equation}
%   其中 $\mathbf{A}$ 等于 $(\mathbf{x}-EX)(\mathbf{x}-EX)^T$，$\mathbf{B}$ 表示协方差阵 $E(X-EX)(X-EX)^T$，$\lambda_1$
% $\mathbf{u}_1$是$\lambda_1$对应的特征向量，
% \end{theorem}

% 对于希腊符号使用\verb|mathbf|命令可能有些问题，所以建议对符号
% 用\verb|bm|加粗，记得用\verb|\up<greek>|切换正体符号，下面看几个例子：
% \verb|\gamma|斜体代表变量$\gamma$，\verb|\bm{\upgamma}|正体代表向量$\bm{\upgamma}$,
% 。\verb|\Gamma|正体代表操作符号$\Gamma$，
% \verb|\bm{\Gamma}|正体粗体代表矩阵形式$\bm{\Gamma}$，
% \verb|\varGamma|斜体代表变量$\varGamma$。另外对于大小写斜体的加粗可以见$\bm{\gamma}$和$\bm{\varGamma}$，
% 但是这两种科技论文中很少出现，这里只做测试。
% 非符号普通向量就用\verb|\mathbf|吧：$\mathbf{x}_k,\mathbf{X}_k$。
% 完整测试如下$\omega,\bm{\omega},\upomega,\bm{\upomega},\Omega,\bm{\Omega},\varOmega,\bm{\varOmega}$。

% \begin{proof}
% 上述优化问题显然是一个Rayleigh商问题。我们有
%   \begin{align}
%      O_R(\mathbf{x},F)=\sqrt{\frac{\mathbf{u}_1^T\mathbf{A}\mathbf{u}_1} {\mathbf{u}_1^T\mathbf{B}\mathbf{u}_1}}=\sqrt{\lambda_1},
%  \end{align}
%  其中 $\lambda_1$ 下列广义特征值问题的最大特征值：
% $$
% \mathbf{A}\mathbf{z}=\lambda\mathbf{B}\mathbf{z}, \mathbf{z}\neq 0.
% $$
%  $\mathbf{u}_1$ 是 $\lambda_1$对应的特征向量。结论成立。
% \end{proof}

% 下面来看看算法环境的定义和使用。
% 我们知道，故障诊断的最终目的，是将故障定位到部件，而由于信号--部件依赖矩阵的存在，因此，实质性的工作是找出由故障部件发出异常信号，
% 不妨称为源异常信号，而如前所述，源异常信号与异常信号依赖矩阵$\mathbf{S_a}$的全零列是存在一一对应的关系的。因此，我们只要获得了$\mathbf{S_a}$的全零列的相关信息，
% 也就获得了源异常信号的信息，从而能进一步找到故障源。
% 通过以上分析，我们构造算法\ref{alg53}，用于实现非回路故障诊断。
% \begin{algorithm}[htbp]
%   \caption{非回路故障诊断算法}
%   \label{alg53}
%   \begin{algorithmic}[1]
%     \REQUIRE 信号--部件依赖矩阵$\mathbf{A}$，信号依赖矩阵$\mathbf{S}$，信号状态向量$\alpha$
%     \ENSURE 部件状态向量$\gamma$
%     \STATE $\mathbf{P}\leftarrow\left(<\alpha>\right)$
%     \STATE $\mathbf{S_{a}}\leftarrow\mathbf{P^T}\mathbf{S}\mathbf{P}$
%     \FOR{$i=1$ to $S_a$的阶数$m$}
%     \STATE $s_i\leftarrow s_i$的第$i$个行向量
%     \ENDFOR
%     \STATE $\beta_a\leftarrow\lnot \left(s_1\lor s_2\lor \cdots\lor s_m\right)^T$
%     \STATE $\beta\leftarrow\mathbf{P}\beta_a$
%     \STATE $\gamma\leftarrow\mathbf{A}\beta$
%   \end{algorithmic}
% \end{algorithm}

% 第一类故障回路推理与非回路故障推理是算法基本相同，稍微不同的是$\beta_a$的计算。因为第一类故障回路中的信号全部可能是源异常信号，因此我们不必计算
% $\beta_a=\lnot \left(\left[s_1\lor s_2\lor \cdots\lor s_m\right]^T\right)$，而直接取$\beta_a=\underbrace{\left[\begin{array}{cccc}1&1&\cdots&1\end{array}\right]^T}_m$，将$\beta_a$代入
% 算法\ref{alg53}，有
% \[\beta=\mathbf{P}\beta_a=\mathbf{P}\underbrace{\left[\begin{array}{cccc}1&1&\cdots&1\end{array}\right]^T}_m=\alpha\]
% 因此一类故障回路的推理算法变得相当简单，例如算法\ref{alg54}
% \begin{algorithm}[htbp]
%   \caption{第一类故障回路诊断算法}
%   \label{alg54}
%   \begin{algorithmic}[1]
%     \REQUIRE 信号--部件依赖矩阵$\mathbf{A}$，信号状态向量$\alpha$
%     \ENSURE 部件状态向量$\gamma$
%     \STATE $\gamma\leftarrow\mathbf{A}\alpha$
%   \end{algorithmic}
% \end{algorithm}

% \section{参考文献}
% \label{sec:bib}
% 当然参考文献可以直接写 bibitem，虽然费点功夫，但是好控制，各种格式可以自己随意改
% 写，在nudtpaper里面，建议使用JabRef编辑和管理文献，再结合\verb|bstutf8.bst|，
% 对中文的支持非常不错，格式也很规范。

% 本模板推荐使用 BIB\TeX，样式文件为 bstutf8.bst，符合学校的参考文献格式（如专利
% 等引用未加详细测试）。看看这个例子，关于书的\upcite{tex, companion}，
% 还有这些\upcite{Krasnogor2004e, clzs, zjsw}，关于杂志的\upcite{ELIDRISSI94,
%   MELLINGER96, SHELL02}，硕士论文\upcite{zhubajie, metamori2004}，博士论文
% \upcite{shaheshang, FistSystem01}，标准文件\upcite{IEEE-1363}，会议论文\upcite{DPMG,kocher99}，%
% 技术报告\upcite{NPB2}。中文参考文献\upcite{cnarticle}\textsf{特别注意}，需要在\verb|bibitem|中
% 增加\verb|language|域并设为\verb|zh|，英文此项可不填，之后由\verb|bstutf8|统一处理
% (具体就是决定一些文献在中英文不同环境下的显示格式，如等、etc)。
% 若使用\verb|JabRef|，则你可按下面步骤来设置：
% 选择\textsf{Options}$\rightarrow$\textsf{Set Up General Fields}，
% 在\verb|General:|后加入\verb|language|就可以了。

% 有时候不想要上标，那么可以这样 \cite{shaheshang}，这个非常重要。

% \section{代码高亮}
% 有些时候我们需要在论文中引入一段代码，用来衬托正文的内容，或者体现关键思路的实现。
% 在模板中，统一使用\texttt{listings}宏包，并且设置了基本的内容格式，并建议用户只
% 使用三个接口，分别控制：编程语言，行号以及边框。简洁达意即可，下面分别举例说明。

% 首先是设定语言，来一个C的，使用的是默认设置：
% \begin{lstlisting}[language=C]
% void sort(int arr[], int beg, int end)
% {
%   if (end > beg + 1)
%   {
%     int piv = arr[beg], l = beg + 1, r = end;
%     while (l < r)
%     {
%       if (arr[l] <= piv)
%         l++;
%       else
%         swap(&arr[l], &arr[--r]);
%     }
%     swap(&arr[--l], &arr[beg]);
%     sort(arr, beg, l);
%     sort(arr, r, end);
%   }
% }
% \end{lstlisting}

% 当我们需要高亮Java代码，不需要行号，不需要边框时，可以：
% \begin{lstlisting}[language=Java,numbers=none,frame=none]
% // A program to display the message
% // "Hello World!" on standard output

% public class HelloWorld {
 
%    public static void main(String[] args) {
%       System.out.println("Hello World!");
%    }
      
% }   // end of class HelloWorld
% \end{lstlisting}

% 细心的用户可能发现，行号被放在了正文框之外，事实上这样是比较美观的，
% 如果有些用户希望在正文框架之内布置所有内容，可以：
% \begin{lstlisting}[language=perl,xleftmargin=2em,framexleftmargin=1.5em]
% #!/usr/bin/perl
% print "Hello, world!\n";
% \end{lstlisting}

% 好了，就这么多，\texttt{listings}宏包的功能很强大也很复杂，如果需要自己定制，
% 可以查看其手册，耐心阅读总会找到答案。
% \textbf{注意:} 当前代码环境中文注释的处理还不是很完善，对于注释请妥善处理。
% 在本模板中，推荐算法环境或者去掉中文的listings代码环境。
% 如果需要包含中文注释，不要求代码高亮，
% 就用\texttt{code}环境，这个环境是Verbatim的定制版，简单有效，
% 调用的是fancyvbr宏包，用户可在mynudt.sty中修改它的外观等等。
% 这里我们还可以给代码加上标签。
% \begin{code}[label=hello.c]
% public class HelloWorld {
%    public static void main(String[] args) {
%       System.out.println("Hello World!");
%    }
% }   // 世界，你好！
% \end{code}

% \section{符号列表}

% {\hei 前面的话：}{\kai\color{blue} 
% 2.2版本后默认使用nomencl环境，如果你还是希望使用传统的\verb|definition.tex|，那么只需注释掉
% 顶层文件中的nomenclature即可。}

% 符号列表使用的是\verb|nomencl|包，自己简单定制了下，使用方法分为四步：
% \begin{compactenum}
% \item 将\verb|\makenomenclature|语句放在正文前，即\verb|\begin{document}|前面；
% \item 将\verb|\printnomenclature|放在论文中，我在例子中将符号列表放在了英文摘要的
% 后面，正文第一章的前面，当然，你可以根据自己的需要或者教研室的规范放置在合理的位置上，
% 为了页面引用的正确，在这句话前面放上\verb|\cleardoublepage|；
% \item 使用\verb|\nomenclature|命令在论文的各个位置上添加符号定义，语法后面会讲到；
% \item 编译。编译需要首先运行一遍xelatex，之后运行
% \begin{code}
% makeindex -s nomencl.ist -o thesis.nls thesis.nlo
% \end{code}
% \end{compactenum}

% 你可以把这句编译命令放在\verb|makepdf.bat|中第一个\verb|xelatex thesis|下面。然后
% 双击\verb|makepdf.bat|就可以了，论文模板中已经为你添加上了，如果你强烈不想使用
% nomencl环境，只要把它注释掉（前面加\verb|rem|）就可以。
% 另外，由于我使用的是VIM来编辑\TeX{}代码，具体到每个编辑器（诸如WinEDT，TeXWorks等）
% 如何设定该命令的快捷按钮，诸位可以搜索网上的教程。

% 下面简单说明下\verb|\nomenclature|命令，语法为。这里插入一些随机的文字，希望
% 对你在阅读帮助中的思维没有什么不良的影响。
% \begin{code}
% \nomenclature[<prefix>]{<symbol>}{<desc>}{<null>}
% \end{code}
% \verb|nomencl|模板的默认排序方法可能（大多都）不满足要求，
% 论文模板里，我们通过设定\verb|<prefix>|来实现符号列表的排序。
% 它分为两部分，比如如\verb|[Aa]|，第一个字母的含义是：
% \begin{compactitem}
% \item[`A'] 符号归为拉丁字母
% \item[`G'] 希腊字母
% \item[`X'] 上标
% \item[`Z'] 下标
% \end{compactitem}
% 每个标识后边的字幕\verb|a-z|作为当前符号组内的排列顺序，比如$\beta$就可以写成
% \verb|[Gb]|，诸如此类。当然你一定注意到了，这个排序分组的设定只是为了记忆
% 方便，并不是强制的，因此你可以有自己的方案，比如Z是Greek，
% R是Roman什么的，只要统一就好，只需记住，组间排列是按字母顺序排的。

% 注意符号表分四列，前三列的含义与命令中相同，
% 最后一列是符号定义时所在的页码。效果看例子，对于下式:
% \begin{equation}\label{eq:heatflux}
%    \dot{Q} = k \cdot A \cdot \Delta T
% \end{equation}%
% \nomenclature[Aq]{$\dot{Q}$}{heat flux}{}%
% \nomenclature[Ak]{$k$}{overall heat transfer coefficient,式\eqref{eq:ohtc}}{}%
% \nomenclature[Aa]{$A$}{area}{}%
% \nomenclature[Al]{$L$}{length}{}%
% \nomenclature[At]{$T$}{temperature}{}%
% \nomenclature[At]{$\Delta T$}{temperature difference}{}%
% \nomenclature[Gr]{$\gamma$}{中文测试, 以及一句很长的物理意义，很有可能超过当前栏的宽度，主要目的是看一看会不会出现某些异常情况。}{}%

% 或者:
% \begin{equation}\label{eq:ohtc}
%     \frac{1}{k} = \left[\frac{1}{\alpha _{\mathrm{i}}\,r_{\mathrm{i}}} +
%     \sum^n_{j=1}\frac{1}{\lambda _j}\,
%     \ln \frac{r_{\mathrm{a},j}}{r_{\mathrm{i},j}} +
%     \frac{1}{\alpha _{\mathrm{a}}\,
%     r_{\mathrm{a}}}\right] \cdot r_{\mathrm{reference}}
% \end{equation}%
% \nomenclature[Ga]{$\alpha$}{convection heat transfer coefficient}{}%
% \nomenclature[Zi]{i}{in}{}%
% \nomenclature[Gl]{$\lambda$}{thermal conductivity}{}%
% \nomenclature[Za]{a}{out}{}%
% \nomenclature[Zn]{$n$}{number of walls}{}%
% \nomenclature[Zj]{$j$}{running parameter}{}%

% {\hei 注意事项：}{\kai 模板中定制的nomencl格式在mynudt.sty中，默认是三栏的，分别是：
% ``符号''，``定义''，``首次出现页码''，
% 注意这里的符号列表都没有单位，如果你需要额外的栏输入单位（呵呵，聪明的读者可能看出来
% 了，\verb|nomenclature|命令最后一个是空的，就是用来让你赋予她各种意义的）。
% 此时就需要你有一点点动手能力了（其实只要会修改表格就行），
% 方法很简单，比如需要添加``国际单位制''这一栏，则
% \begin{compactenum}
% \item 论文中\verb|\nomenclature|命令的第三个参数就让他代表单位，也可留空；
% \item 将\verb|mynudt.sty|中longtable的表头添加``国际单位制''几个字，
% 你也可以取其他的名字，放在那个{\kai 应该出现的}位置上；
% \item 由于增加了5个字，就把前面栏的宽度数字减5，同时设定第三栏宽度为5，
% 注意这一步需要你自己调整，记得不要让表格超出边界就行。
% \end{compactenum}
% }

% \section{中文习惯}
% \label{sec:chinese}

% 对于itermize过大的行间距，用户可以使用compactitem环境来替代，但是模板中不进行默认替代，
% 因为只有用户真正发现列表不好看才会找到这里，而且在示例文件中，
% 陈赓大将那个列表环境如果压缩了行距会很不好看。谢谢ZhangLei的建议！

% {\hei 一个重要的提示：}
% 作者自己的定义命令、包等，不要放在模板里面，请放到\verb|mynudt.sty|
% 中，这样模板时，只要覆盖\verb|nudtpaper.cls|即可。

% 中文破折号为一个两个字宽垂直居中的直线，输入法直接得到的破折号是两个断开的小短线
% （——），这看起来不舒服。所以模板中定义了一个破折号的命令 \verb|\pozhehao|，请看：

% 厚德博学，强军兴国\hfill \pozhehao{}国防科大校训

